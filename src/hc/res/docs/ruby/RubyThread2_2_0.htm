<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.39.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta name='description' content='  Class : Thread  -   Ruby 2.2.0 ' />
  <meta content="2017-09-09 18:34:27 -0500" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = true-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: Thread (Ruby 2.2.0) </title>
  <link rel="stylesheet" href="/css/associated.css" type="text/css" >
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="/css/inuit.css" >
  <link rel="stylesheet" href="/css/grid.inuit.css" >
  <link rel="stylesheet" href="/css/2011.css" type="text/css" >
  <link rel="stylesheet" href="/css/rdoc.css" type="text/css" >
    <link rel="stylesheet" href="/css/carbon17.css" type="text/css" >


  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 


   
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

   <link rel="stylesheet" href="/css/extra.css" type="text/css" >
  <script  src="/js/extra.js"  ></script>


</head>

<body id="top" class="class rdocstar">

<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'>
	<li class='grid-2' ><a href='/' target='_top' >Home</a></li>
	<li class='grid-2' ><a href='/core-2.2.0' target='_top' >Core 2.2.0</a></li>
	<li class='grid-2' ><a href='/stdlib-2.2.0' target='_top' >Std-lib 2.2.0</a></li>

   <li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
	 <li class='grid-5 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="http://ruby-doc.com/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input  id='rd-search-input' name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form></li>
	</ul>
</div>
<span id='vulns-alert'></span>
<div id='versionheader'>
<p>Support for the Ruby 2.2 series will end March 2018. See <a href='https://www.ruby-lang.org/en/news/2017/04/01/support-of-ruby-2-1-has-ended/'>here</a> for reference.</p>
</div>
</div> <!-- end action bar -->
 <div class='wrapper'>
  
   <!-- carbon17 added here 2017-09-09 -->
 
   <script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>
<div class="bsa-cpc"></div>
<script>
  (function(){
    if(typeof _bsa !== 'undefined' && _bsa) {
    _bsa.init('default', 'CKYD627W', 'placement:rubydocorg', {
      target: '.bsa-cpc',
      align: 'horizontal',
      disable_css: 'true'
    });
      }
  })();
</script>

 

   <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
          
          <!-- br><a id='alternateFormatLink' class='rotate' href="#" onclick='matchingYardUrl()'>YARD version</a -->
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>prelude.rb</li>      
            
          
          <li class='in-file'>thread.c</li>      
            
          
          <li class='in-file'>vm.c</li>      
            
          
          <li class='in-file'>vm_trace.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      
      <!-- Namespace Contents -->
      <div id="namespace-list-section" class="section">
        <h3 class="section-header">Namespace</h3>
        <ul class="link-list">
          
          <li><span class="type">CLASS</span> <a href="Thread/Backtrace.html">Thread::Backtrace</a></li>
          
        </ul>
      </div>
      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-DEBUG">::DEBUG</a></li>
          
          <li><a href="#method-c-DEBUG-3D">::DEBUG=</a></li>
          
          <li><a href="#method-c-abort_on_exception">::abort_on_exception</a></li>
          
          <li><a href="#method-c-abort_on_exception-3D">::abort_on_exception=</a></li>
          
          <li><a href="#method-c-current">::current</a></li>
          
          <li><a href="#method-c-exclusive">::exclusive</a></li>
          
          <li><a href="#method-c-exit">::exit</a></li>
          
          <li><a href="#method-c-fork">::fork</a></li>
          
          <li><a href="#method-c-handle_interrupt">::handle_interrupt</a></li>
          
          <li><a href="#method-c-kill">::kill</a></li>
          
          <li><a href="#method-c-list">::list</a></li>
          
          <li><a href="#method-c-main">::main</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-pass">::pass</a></li>
          
          <li><a href="#method-c-pending_interrupt-3F">::pending_interrupt?</a></li>
          
          <li><a href="#method-c-start">::start</a></li>
          
          <li><a href="#method-c-stop">::stop</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-abort_on_exception">#abort_on_exception</a></li>
          
          <li><a href="#method-i-abort_on_exception-3D">#abort_on_exception=</a></li>
          
          <li><a href="#method-i-add_trace_func">#add_trace_func</a></li>
          
          <li><a href="#method-i-alive-3F">#alive?</a></li>
          
          <li><a href="#method-i-backtrace">#backtrace</a></li>
          
          <li><a href="#method-i-backtrace_locations">#backtrace_locations</a></li>
          
          <li><a href="#method-i-exit">#exit</a></li>
          
          <li><a href="#method-i-group">#group</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-join">#join</a></li>
          
          <li><a href="#method-i-key-3F">#key?</a></li>
          
          <li><a href="#method-i-keys">#keys</a></li>
          
          <li><a href="#method-i-kill">#kill</a></li>
          
          <li><a href="#method-i-pending_interrupt-3F">#pending_interrupt?</a></li>
          
          <li><a href="#method-i-priority">#priority</a></li>
          
          <li><a href="#method-i-priority-3D">#priority=</a></li>
          
          <li><a href="#method-i-raise">#raise</a></li>
          
          <li><a href="#method-i-run">#run</a></li>
          
          <li><a href="#method-i-safe_level">#safe_level</a></li>
          
          <li><a href="#method-i-set_trace_func">#set_trace_func</a></li>
          
          <li><a href="#method-i-status">#status</a></li>
          
          <li><a href="#method-i-stop-3F">#stop?</a></li>
          
          <li><a href="#method-i-terminate">#terminate</a></li>
          
          <li><a href="#method-i-thread_variable-3F">#thread_variable?</a></li>
          
          <li><a href="#method-i-thread_variable_get">#thread_variable_get</a></li>
          
          <li><a href="#method-i-thread_variable_set">#thread_variable_set</a></li>
          
          <li><a href="#method-i-thread_variables">#thread_variables</a></li>
          
          <li><a href="#method-i-value">#value</a></li>
          
          <li><a href="#method-i-wakeup">#wakeup</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul id='files'>
        
          
          <li class="file"><a href="./_lib/racc/rdoc/grammar_en_rdoc.html">grammar.en.rdoc</a></li>
        
          
          <li class="file"><a href="./_test/rdoc/test_ja_rdoc.html">test.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/contributing_rdoc.html">contributing.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/contributors_rdoc.html">contributors.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/dtrace_probes_rdoc.html">dtrace_probes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/globals_rdoc.html">globals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/keywords_rdoc.html">keywords.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/maintainers_rdoc.html">maintainers.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/marshal_rdoc.html">marshal.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/regexp_rdoc.html">regexp.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/security_rdoc.html">security.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/standard_library_rdoc.html">standard_library.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax_rdoc.html">syntax.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/assignment_rdoc.html">assignment.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/calling_methods_rdoc.html">calling_methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/control_expressions_rdoc.html">control_expressions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/exceptions_rdoc.html">exceptions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/literals_rdoc.html">literals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/methods_rdoc.html">methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/miscellaneous_rdoc.html">miscellaneous.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/modules_and_classes_rdoc.html">modules_and_classes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/precedence_rdoc.html">precedence.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/refinements_rdoc.html">refinements.rdoc</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_ja_rdoc.html">README.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_rdoc.html">README.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="./Array.html">Array</a></li>
        
          
          
          <li><a href="./BasicObject.html">BasicObject</a></li>
        
          
          
          <li><a href="./Bignum.html">Bignum</a></li>
        
          
          
          <li><a href="./Binding.html">Binding</a></li>
        
          
          
          <li><a href="./Class.html">Class</a></li>
        
          
          
          <li><a href="./Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="./Complex.html">Complex</a></li>
        
          
          
          <li><a href="./Complex/compatible.html">Complex::compatible</a></li>
        
          
          
          <li><a href="./ConditionVariable.html">ConditionVariable</a></li>
        
          
          
          <li><a href="./Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="./Data.html">Data</a></li>
        
          
          
          <li><a href="./Dir.html">Dir</a></li>
        
          
          
          <li><a href="./ENV.html">ENV</a></li>
        
          
          
          <li><a href="./EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="./Encoding.html">Encoding</a></li>
        
          
          
          <li><a href="./Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          
          
          <li><a href="./Encoding/Converter.html">Encoding::Converter</a></li>
        
          
          
          <li><a href="./Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          
          
          <li><a href="./Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          
          
          <li><a href="./Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          
          
          <li><a href="./EncodingError.html">EncodingError</a></li>
        
          
          
          <li><a href="./Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="./Enumerator.html">Enumerator</a></li>
        
          
          
          <li><a href="./Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          
          
          <li><a href="./Enumerator/Lazy.html">Enumerator::Lazy</a></li>
        
          
          
          <li><a href="./Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          
          
          <li><a href="./Errno.html">Errno</a></li>
        
          
          
          <li><a href="./Exception.html">Exception</a></li>
        
          
          
          <li><a href="./FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="./Fiber.html">Fiber</a></li>
        
          
          
          <li><a href="./FiberError.html">FiberError</a></li>
        
          
          
          <li><a href="./File.html">File</a></li>
        
          
          
          <li><a href="./File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="./File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="./FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="./Fixnum.html">Fixnum</a></li>
        
          
          
          <li><a href="./Float.html">Float</a></li>
        
          
          
          <li><a href="./FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="./GC.html">GC</a></li>
        
          
          
          <li><a href="./GC/Profiler.html">GC::Profiler</a></li>
        
          
          
          <li><a href="./Hash.html">Hash</a></li>
        
          
          
          <li><a href="./IO.html">IO</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitReadable.html">IO::EAGAINWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitWritable.html">IO::EAGAINWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitReadable.html">IO::EINPROGRESSWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitWritable.html">IO::EINPROGRESSWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitReadable.html">IO::EWOULDBLOCKWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitWritable.html">IO::EWOULDBLOCKWaitWritable</a></li>
        
          
          
          <li><a href="./IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          
          
          <li><a href="./IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          
          
          <li><a href="./IOError.html">IOError</a></li>
        
          
          
          <li><a href="./IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="./Integer.html">Integer</a></li>
        
          
          
          <li><a href="./Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="./Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="./KeyError.html">KeyError</a></li>
        
          
          
          <li><a href="./LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="./LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="./Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="./MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="./Math.html">Math</a></li>
        
          
          
          <li><a href="./Math/DomainError.html">Math::DomainError</a></li>
        
          
          
          <li><a href="./Method.html">Method</a></li>
        
          
          
          <li><a href="./Module.html">Module</a></li>
        
          
          
          <li><a href="./Mutex.html">Mutex</a></li>
        
          
          
          <li><a href="./NameError.html">NameError</a></li>
        
          
          
          <li><a href="./NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="./NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="./NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="./NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="./Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="./Object.html">Object</a></li>
        
          
          
          <li><a href="./ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="./ObjectSpace/WeakMap.html">ObjectSpace::WeakMap</a></li>
        
          
          
          <li><a href="./Proc.html">Proc</a></li>
        
          
          
          <li><a href="./Process.html">Process</a></li>
        
          
          
          <li><a href="./Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="./Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="./Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="./Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="./Process/Waiter.html">Process::Waiter</a></li>
        
          
          
          <li><a href="./Queue.html">Queue</a></li>
        
          
          
          <li><a href="./Random.html">Random</a></li>
        
          
          
          <li><a href="./Range.html">Range</a></li>
        
          
          
          <li><a href="./RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="./Rational.html">Rational</a></li>
        
          
          
          <li><a href="./Rational/compatible.html">Rational::compatible</a></li>
        
          
          
          <li><a href="./Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="./RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="./RubyVM.html">RubyVM</a></li>
        
          
          
          <li><a href="./RubyVM/Env.html">RubyVM::Env</a></li>
        
          
          
          <li><a href="./RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          
          
          <li><a href="./RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="./ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="./SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="./Signal.html">Signal</a></li>
        
          
          
          <li><a href="./SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="./SizedQueue.html">SizedQueue</a></li>
        
          
          
          <li><a href="./StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="./StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="./String.html">String</a></li>
        
          
          
          <li><a href="./Struct.html">Struct</a></li>
        
          
          
          <li><a href="./Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="./SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="./SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="./SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="./SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="./Thread.html">Thread</a></li>
        
          
          
          <li><a href="./Thread/Backtrace/Location.html">Thread::Backtrace::Location</a></li>
        
          
          
          <li><a href="./ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="./ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="./Time.html">Time</a></li>
        
          
          
          <li><a href="./TracePoint.html">TracePoint</a></li>
        
          
          
          <li><a href="./TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="./TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="./UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="./UncaughtThrowError.html">UncaughtThrowError</a></li>
        
          
          
          <li><a href="./ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="./fatal.html">fatal</a></li>
        
          
          
          <li><a href="./unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
   <div id="carbonads-container"><div class="carbonad">
    <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=rubydocorg" 
      id="_carbonads_js">
      </script>
  </div></div>

   
  </div> 
  <div id="documentation">
    <h1 class="class">Thread</h1>

    <div id="description" class="description">
      
<p>Threads are the Ruby implementation for a concurrent programming model.</p>

<p>Programs that require multiple threads of execution are a perfect candidate
for Ruby's <a href="Thread.html">Thread</a> class.</p>

<p>For example, we can create a new thread separate from the main thread's
execution using <a href="Thread.html#method-c-new">::new</a>.</p>

<pre class="ruby"><span class="ruby-identifier">thr</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Whats the big deal&quot;</span> }
</pre>

<p>Then we are able to pause the execution of the main thread and allow our
new thread to finish, using <a href="Thread.html#method-i-join">join</a>:</p>

<pre class="ruby"><span class="ruby-identifier">thr</span>.<span class="ruby-identifier">join</span> <span class="ruby-comment">#=&gt; &quot;Whats the big deal&quot;</span>
</pre>

<p>If we don't call <code>thr.join</code> before the main thread terminates,
then all other threads including <code>thr</code> will be killed.</p>

<p>Alternatively, you can use an array for handling multiple threads at once,
like in the following example:</p>

<pre class="ruby"><span class="ruby-identifier">threads</span> = []
<span class="ruby-identifier">threads</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Whats the big deal&quot;</span> }
<span class="ruby-identifier">threads</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-value">3</span>.<span class="ruby-identifier">times</span> { <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Threads are fun!&quot;</span> } }
</pre>

<p>After creating a few threads we wait for them all to finish consecutively.</p>

<pre class="ruby"><span class="ruby-identifier">threads</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">thr</span><span class="ruby-operator">|</span> <span class="ruby-identifier">thr</span>.<span class="ruby-identifier">join</span> }
</pre>

<h3 id="class-Thread-label-Thread+initialization"><a href="Thread.html">Thread</a> initialization<span><a href="#class-Thread-label-Thread+initialization">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In order to create new threads, Ruby provides <a
href="Thread.html#method-c-new">::new</a>, <a
href="Thread.html#method-c-start">::start</a>, and <a
href="Thread.html#method-c-fork">::fork</a>. A block must be provided with
each of these methods, otherwise a <a
href="ThreadError.html">ThreadError</a> will be raised.</p>

<p>When subclassing the <a href="Thread.html">Thread</a> class, the
<code>initialize</code> method of your subclass will be ignored by <a
href="Thread.html#method-c-start">::start</a> and <a
href="Thread.html#method-c-fork">::fork</a>. Otherwise, be sure to call
super in your <code>initialize</code> method.</p>

<h3 id="class-Thread-label-Thread+termination"><a href="Thread.html">Thread</a> termination<span><a href="#class-Thread-label-Thread+termination">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>For terminating threads, Ruby provides a variety of ways to do this.</p>

<p>The class method <a href="Thread.html#method-c-kill">::kill</a>, is meant
to exit a given thread:</p>

<pre>thr = Thread.new { ... }
Thread.kill(thr) # sends exit() to thr</pre>

<p>Alternatively, you can use the instance method <a
href="Thread.html#method-i-exit">exit</a>, or any of its aliases <a
href="Thread.html#method-i-kill">kill</a> or <a
href="Thread.html#method-i-terminate">terminate</a>.</p>

<pre class="ruby"><span class="ruby-identifier">thr</span>.<span class="ruby-identifier">exit</span>
</pre>

<h3 id="class-Thread-label-Thread+status"><a href="Thread.html">Thread</a> status<span><a href="#class-Thread-label-Thread+status">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Ruby provides a few instance methods for querying the state of a given
thread. To get a string with the current thread's state use <a
href="Thread.html#method-i-status">status</a></p>

<pre class="ruby"><span class="ruby-identifier">thr</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span> }
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">status</span> <span class="ruby-comment"># =&gt; &quot;sleep&quot;</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">exit</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">status</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>You can also use <a href="Thread.html#method-i-alive-3F">alive?</a> to tell
if the thread is running or sleeping, and <a
href="Thread.html#method-i-stop-3F">stop?</a> if the thread is dead or
sleeping.</p>

<h3 id="class-Thread-label-Thread+variables+and+scope"><a href="Thread.html">Thread</a> variables and scope<span><a href="#class-Thread-label-Thread+variables+and+scope">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Since threads are created with blocks, the same rules apply to other Ruby
blocks for variable scope. Any local variables created within this block
are accessible to only this thread.</p>

<h4 id="class-Thread-label-Fiber-local+vs.+Thread-local">Fiber-local vs. Thread-local<span><a href="#class-Thread-label-Fiber-local+vs.+Thread-local">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Each fiber has its own bucket for <a
href="Thread.html#method-i-5B-5D">#[]</a> storage. When you set a new
fiber-local it is only accessible within this <a
href="Fiber.html">Fiber</a>. To illustrate:</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">foo</span>] = <span class="ruby-string">&quot;bar&quot;</span>
  <span class="ruby-constant">Fiber</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-identifier">p</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">foo</span>] <span class="ruby-comment"># =&gt; nil</span>
  }.<span class="ruby-identifier">resume</span>
}.<span class="ruby-identifier">join</span>
</pre>

<p>This example uses <a href="Thread.html#method-i-5B-5D">[]</a> for getting
and <a href="Thread.html#method-i-5B-5D-3D">[]=</a> for setting
fiber-locals, you can also use <a href="Thread.html#method-i-keys">keys</a>
to list the fiber-locals for a given thread and <a
href="Thread.html#method-i-key-3F">key?</a> to check if a fiber-local
exists.</p>

<p>When it comes to thread-locals, they are accessible within the entire scope
of the thread. Given the following example:</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span>{
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">thread_variable_set</span>(:<span class="ruby-identifier">foo</span>, <span class="ruby-value">1</span>)
  <span class="ruby-identifier">p</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">thread_variable_get</span>(:<span class="ruby-identifier">foo</span>) <span class="ruby-comment"># =&gt; 1</span>
  <span class="ruby-constant">Fiber</span>.<span class="ruby-identifier">new</span>{
    <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">thread_variable_set</span>(:<span class="ruby-identifier">foo</span>, <span class="ruby-value">2</span>)
    <span class="ruby-identifier">p</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">thread_variable_get</span>(:<span class="ruby-identifier">foo</span>) <span class="ruby-comment"># =&gt; 2</span>
  }.<span class="ruby-identifier">resume</span>
  <span class="ruby-identifier">p</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">thread_variable_get</span>(:<span class="ruby-identifier">foo</span>)   <span class="ruby-comment"># =&gt; 2</span>
}.<span class="ruby-identifier">join</span>
</pre>

<p>You can see that the thread-local <code>:foo</code> carried over into the
fiber and was changed to <code>2</code> by the end of the thread.</p>

<p>This example makes use of <a
href="Thread.html#method-i-thread_variable_set">thread_variable_set</a> to
create new thread-locals, and <a
href="Thread.html#method-i-thread_variable_get">thread_variable_get</a> to
reference them.</p>

<p>There is also <a
href="Thread.html#method-i-thread_variables">thread_variables</a> to list
all thread-locals, and <a
href="Thread.html#method-i-thread_variable-3F">thread_variable?</a> to
check if a given thread-local exists.</p>

<h3 id="class-Thread-label-Exception+handling"><a href="Exception.html">Exception</a> handling<span><a href="#class-Thread-label-Exception+handling">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Any thread can raise an exception using the <a
href="Thread.html#method-i-raise">raise</a> instance method, which operates
similarly to <a href="Kernel.html#method-i-raise">Kernel#raise</a>.</p>

<p>However, it's important to note that an exception that occurs in any thread
except the main thread depends on <a
href="Thread.html#method-i-abort_on_exception">abort_on_exception</a>. This
option is <code>false</code> by default, meaning that any unhandled
exception will cause the thread to terminate silently when waited on by
either <a href="Thread.html#method-i-join">join</a> or <a
href="Thread.html#method-i-value">value</a>. You can change this default by
either <a
href="Thread.html#method-i-abort_on_exception-3D">abort_on_exception=</a>
<code>true</code> or setting $DEBUG to <code>true</code>.</p>

<p>With the addition of the class method <a
href="Thread.html#method-c-handle_interrupt">::handle_interrupt</a>, you
can now handle exceptions asynchronously with threads.</p>

<h3 id="class-Thread-label-Scheduling">Scheduling<span><a href="#class-Thread-label-Scheduling">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Ruby provides a few ways to support scheduling threads in your program.</p>

<p>The first way is by using the class method <a
href="Thread.html#method-c-stop">::stop</a>, to put the current running
thread to sleep and schedule the execution of another thread.</p>

<p>Once a thread is asleep, you can use the instance method <a
href="Thread.html#method-i-wakeup">wakeup</a> to mark your thread as
eligible for scheduling.</p>

<p>You can also try <a href="Thread.html#method-c-pass">::pass</a>, which
attempts to pass execution to another thread but is dependent on the OS
whether a running thread will switch or not. The same goes for <a
href="Thread.html#method-i-priority">priority</a>, which lets you hint to
the thread scheduler which threads you want to take precedence when passing
execution. This method is also dependent on the OS and may be ignored on
some platforms.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="DEBUG-method" class="method-detail ">
          <a name="method-c-DEBUG"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">DEBUG     &rarr; num</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the thread debug level.  Available only if compiled with
THREAD_DEBUG=-1.</p>
            

            
            <div class="method-source-code" id="DEBUG-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_s_debug(void)
{
    return INT2NUM(rb_thread_debug_enabled);
}
            </pre> 
            </div><!-- DEBUG-source -->
            
          </div>

          

          
        </div><!-- DEBUG-method -->
      
        <div id="DEBUG-3D-method" class="method-detail ">
          <a name="method-c-DEBUG-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">DEBUG = num</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the thread debug level.  Available only if compiled with
THREAD_DEBUG=-1.</p>
            

            
            <div class="method-source-code" id="DEBUG-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_s_debug_set(VALUE self, VALUE val)
{
    rb_thread_debug_enabled = RTEST(val) ? NUM2INT(val) : 0;
    return val;
}
            </pre> 
            </div><!-- DEBUG-3D-source -->
            
          </div>

          

          
        </div><!-- DEBUG-3D-method -->
      
        <div id="abort_on_exception-method" class="method-detail ">
          <a name="method-c-abort_on_exception"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">abort_on_exception   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the status of the global “abort on exception” condition.</p>

<p>The default is <code>false</code>.</p>

<p>When set to <code>true</code>, all threads will abort (the process will
<code>exit(0)</code>) if an exception is raised in any thread.</p>

<p>Can also be specified by the global $DEBUG flag or command line option
<code>-d</code>.</p>

<p>See also <a
href="Thread.html#method-c-abort_on_exception-3D">::abort_on_exception=</a>.</p>

<p>There is also an instance level method to set this for a specific thread,
see <a
href="Thread.html#method-i-abort_on_exception">abort_on_exception</a>.</p>
            

            
            <div class="method-source-code" id="abort_on_exception-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_s_abort_exc(void)
{
    return GET_THREAD()-&gt;vm-&gt;thread_abort_on_exception ? Qtrue : Qfalse;
}
            </pre> 
            </div><!-- abort_on_exception-source -->
            
          </div>

          

          
        </div><!-- abort_on_exception-method -->
      
        <div id="abort_on_exception-3D-method" class="method-detail ">
          <a name="method-c-abort_on_exception-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">abort_on_exception= boolean   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>When set to <code>true</code>, all threads will abort if an exception is
raised. Returns the new state.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">abort_on_exception</span> = <span class="ruby-keyword">true</span>
<span class="ruby-identifier">t1</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">puts</span>  <span class="ruby-string">&quot;In new thread&quot;</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Exception from thread&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">sleep</span>(<span class="ruby-value">1</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;not reached&quot;</span>
</pre>

<p>This will produce:</p>

<pre>In new thread
prog.rb:4: Exception from thread (RuntimeError)
 from prog.rb:2:in `initialize'
 from prog.rb:2:in `new'
 from prog.rb:2</pre>

<p>See also <a
href="Thread.html#method-c-abort_on_exception">::abort_on_exception</a>.</p>

<p>There is also an instance level method to set this for a specific thread,
see <a
href="Thread.html#method-i-abort_on_exception-3D">abort_on_exception=</a>.</p>
            

            
            <div class="method-source-code" id="abort_on_exception-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_s_abort_exc_set(VALUE self, VALUE val)
{
    GET_THREAD()-&gt;vm-&gt;thread_abort_on_exception = RTEST(val);
    return val;
}
            </pre> 
            </div><!-- abort_on_exception-3D-source -->
            
          </div>

          

          
        </div><!-- abort_on_exception-3D-method -->
      
        <div id="current-method" class="method-detail ">
          <a name="method-c-current"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">current   &rarr; thread</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the currently executing thread.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>   <span class="ruby-comment">#=&gt; #&lt;Thread:0x401bdf4c run&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="current-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_s_current(VALUE klass)
{
    return rb_thread_current();
}
            </pre> 
            </div><!-- current-source -->
            
          </div>

          

          
        </div><!-- current-method -->
      
        <div id="exclusive-method" class="method-detail ">
          <a name="method-c-exclusive"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">exclusive { block }   => obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Wraps the block in a single, VM-global <a
href="Mutex.html#method-i-synchronize">Mutex#synchronize</a>, returning the
value of the block. A thread executing inside the exclusive section will
only block other threads which also use the <a
href="Thread.html#method-c-exclusive">::exclusive</a> mechanism.</p>
            

            
            <div class="method-source-code" id="exclusive-source">
              <pre> <!-- method.markup_code 290 -->
               <span class="ruby-comment"># File prelude.rb, line 10</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">exclusive</span>
  <span class="ruby-constant">MUTEX_FOR_THREAD_EXCLUSIVE</span>.<span class="ruby-identifier">synchronize</span>{
    <span class="ruby-keyword">yield</span>
  }
<span class="ruby-keyword">end</span>
            </pre> 
            </div><!-- exclusive-source -->
            
          </div>

          

          
        </div><!-- exclusive-method -->
      
        <div id="exit-method" class="method-detail ">
          <a name="method-c-exit"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">exit   &rarr; thread</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Terminates the currently running thread and schedules another thread to be
run.</p>

<p>If this thread is already marked to be killed, <a
href="Thread.html#method-c-exit">::exit</a> returns the <a
href="Thread.html">Thread</a>.</p>

<p>If this is the main thread, or the last  thread, exit the process.</p>
            

            
            <div class="method-source-code" id="exit-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_exit(void)
{
    rb_thread_t *th = GET_THREAD();
    return rb_thread_kill(th-&gt;self);
}
            </pre> 
            </div><!-- exit-source -->
            
          </div>

          

          
        </div><!-- exit-method -->
      
        <div id="fork-method" class="method-detail ">
          <a name="method-c-fork"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fork([args]*) {|args| block }    &rarr; thread</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Basically the same as <a href="Thread.html#method-c-new">::new</a>.
However, if class <a href="Thread.html">Thread</a> is subclassed, then
calling <code>start</code> in that subclass will not invoke the subclass’s
<code>initialize</code> method.</p>
            

            
            <div class="method-source-code" id="fork-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_start(VALUE klass, VALUE args)
{
    return thread_create_core(rb_thread_alloc(klass), args, 0);
}
            </pre> 
            </div><!-- fork-source -->
            
          </div>

          

          
        </div><!-- fork-method -->
      
        <div id="handle_interrupt-method" class="method-detail ">
          <a name="method-c-handle_interrupt"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">handle_interrupt(hash) { ... } &rarr; result of the block</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Changes asynchronous interrupt timing.</p>

<p><em>interrupt</em> means asynchronous event and corresponding procedure by
<a href="Thread.html#method-i-raise">#raise</a>, <a
href="Thread.html#method-i-kill">#kill</a>, signal trap (not supported yet)
and main thread termination (if main thread terminates, then all other
thread will be killed).</p>

<p>The given <code>hash</code> has pairs like <code>ExceptionClass =&gt;
:TimingSymbol</code>. Where the ExceptionClass is the interrupt handled by
the given block. The TimingSymbol can be one of the following symbols:</p>
<dl class="rdoc-list label-list"><dt><code>:immediate</code>
<dd>
<p>Invoke interrupts immediately.</p>
</dd><dt><code>:on_blocking</code>
<dd>
<p>Invoke interrupts while <em>BlockingOperation</em>.</p>
</dd><dt><code>:never</code>
<dd>
<p>Never invoke all interrupts.</p>
</dd></dl>

<p><em>BlockingOperation</em> means that the operation will block the calling
thread, such as read and write.  On CRuby implementation,
<em>BlockingOperation</em> is any operation executed without GVL.</p>

<p>Masked asynchronous interrupts are delayed until they are enabled. This
method is similar to sigprocmask(3).</p>

<h3 id="method-c-handle_interrupt-label-NOTE">NOTE<span><a href="#method-c-handle_interrupt-label-NOTE">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Asynchronous interrupts are difficult to use.</p>

<p>If you need to communicate between threads, please consider to use another
way such as <a href="Queue.html">Queue</a>.</p>

<p>Or use them with deep understanding about this method.</p>

<h3 id="method-c-handle_interrupt-label-Usage">Usage<span><a href="#method-c-handle_interrupt-label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In this example, we can guard from <a
href="Thread.html#method-i-raise">#raise</a> exceptions.</p>

<p>Using the <code>:never</code> TimingSymbol the <a
href="RuntimeError.html">RuntimeError</a> exception will always be ignored
in the first block of the main thread. In the second <a
href="Thread.html#method-c-handle_interrupt">::handle_interrupt</a> block
we can purposefully handle <a href="RuntimeError.html">RuntimeError</a>
exceptions.</p>

<pre class="ruby"><span class="ruby-identifier">th</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">handle_interrupt</span>(<span class="ruby-constant">RuntimeError</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">never</span>) {
    <span class="ruby-keyword">begin</span>
      <span class="ruby-comment"># You can write resource allocation code safely.</span>
      <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">handle_interrupt</span>(<span class="ruby-constant">RuntimeError</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">immediate</span>) {
        <span class="ruby-comment"># ...</span>
      }
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-comment"># You can write resource deallocation code safely.</span>
    <span class="ruby-keyword">end</span>
  }
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">pass</span>
<span class="ruby-comment"># ...</span>
<span class="ruby-identifier">th</span>.<span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;stop&quot;</span>
</pre>

<p>While we are ignoring the <a href="RuntimeError.html">RuntimeError</a>
exception, it’s safe to write our resource allocation code. Then, the
ensure block is where we can safely deallocate your resources.</p>

<h4 id="method-c-handle_interrupt-label-Guarding+from+Timeout-3A-3AError">Guarding from Timeout::Error<span><a href="#method-c-handle_interrupt-label-Guarding+from+Timeout-3A-3AError">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>In the next example, we will guard from the Timeout::Error exception. This
will help prevent from leaking resources when Timeout::Error exceptions
occur during normal ensure clause. For this example we use the help of the
standard library Timeout, from lib/timeout.rb</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'timeout'</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">handle_interrupt</span>(<span class="ruby-constant">Timeout</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">never</span>) {
  <span class="ruby-identifier">timeout</span>(<span class="ruby-value">10</span>){
    <span class="ruby-comment"># Timeout::Error doesn't occur here</span>
    <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">handle_interrupt</span>(<span class="ruby-constant">Timeout</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">on_blocking</span>) {
      <span class="ruby-comment"># possible to be killed by Timeout::Error</span>
      <span class="ruby-comment"># while blocking operation</span>
    }
    <span class="ruby-comment"># Timeout::Error doesn't occur here</span>
  }
}
</pre>

<p>In the first part of the <code>timeout</code> block, we can rely on
Timeout::Error being ignored. Then in the <code>Timeout::Error =&gt;
:on_blocking</code> block, any operation that will block the calling thread
is susceptible to a Timeout::Error exception being raised.</p>

<h4 id="method-c-handle_interrupt-label-Stack+control+settings">Stack control settings<span><a href="#method-c-handle_interrupt-label-Stack+control+settings">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>It’s possible to stack multiple levels of <a
href="Thread.html#method-c-handle_interrupt">::handle_interrupt</a> blocks
in order to control more than one ExceptionClass and TimingSymbol at a
time.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">handle_interrupt</span>(<span class="ruby-constant">FooError</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">never</span>) {
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">handle_interrupt</span>(<span class="ruby-constant">BarError</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">never</span>) {
     <span class="ruby-comment"># FooError and BarError are prohibited.</span>
  }
}
</pre>

<h4 id="method-c-handle_interrupt-label-Inheritance+with+ExceptionClass">Inheritance with ExceptionClass<span><a href="#method-c-handle_interrupt-label-Inheritance+with+ExceptionClass">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>All exceptions inherited from the ExceptionClass parameter will be
considered.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">handle_interrupt</span>(<span class="ruby-constant">Exception</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">never</span>) {
  <span class="ruby-comment"># all exceptions inherited from Exception are prohibited.</span>
}
</pre>
            

            
            <div class="method-source-code" id="handle_interrupt-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_s_handle_interrupt(VALUE self, VALUE mask_arg)
{
    VALUE mask;
    rb_thread_t *th = GET_THREAD();
    VALUE r = Qnil;
    int state;

    if (!rb_block_given_p()) {
        rb_raise(rb_eArgError, &quot;block is needed.&quot;);
    }

    mask = rb_convert_type(mask_arg, T_HASH, &quot;Hash&quot;, &quot;to_hash&quot;);
    rb_hash_foreach(mask, handle_interrupt_arg_check_i, 0);
    rb_ary_push(th-&gt;pending_interrupt_mask_stack, mask);
    if (!rb_threadptr_pending_interrupt_empty_p(th)) {
        th-&gt;pending_interrupt_queue_checked = 0;
        RUBY_VM_SET_INTERRUPT(th);
    }

    TH_PUSH_TAG(th);
    if ((state = EXEC_TAG()) == 0) {
        r = rb_yield(Qnil);
    }
    TH_POP_TAG();

    rb_ary_pop(th-&gt;pending_interrupt_mask_stack);
    if (!rb_threadptr_pending_interrupt_empty_p(th)) {
        th-&gt;pending_interrupt_queue_checked = 0;
        RUBY_VM_SET_INTERRUPT(th);
    }

    RUBY_VM_CHECK_INTS(th);

    if (state) {
        JUMP_TAG(state);
    }

    return r;
}
            </pre> 
            </div><!-- handle_interrupt-source -->
            
          </div>

          

          
        </div><!-- handle_interrupt-method -->
      
        <div id="kill-method" class="method-detail ">
          <a name="method-c-kill"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">kill(thread)   &rarr; thread</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Causes the given <code>thread</code> to exit, see also <a
href="Thread.html#method-c-exit">::exit</a>.</p>

<pre class="ruby"><span class="ruby-identifier">count</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">loop</span> { <span class="ruby-identifier">count</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> } }
<span class="ruby-identifier">sleep</span>(<span class="ruby-value">0.1</span>)       <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">kill</span>(<span class="ruby-identifier">a</span>)   <span class="ruby-comment">#=&gt; #&lt;Thread:0x401b3d30 dead&gt;</span>
<span class="ruby-identifier">count</span>            <span class="ruby-comment">#=&gt; 93947</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">alive?</span>         <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="kill-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_s_kill(VALUE obj, VALUE th)
{
    return rb_thread_kill(th);
}
            </pre> 
            </div><!-- kill-source -->
            
          </div>

          

          
        </div><!-- kill-method -->
      
        <div id="list-method" class="method-detail ">
          <a name="method-c-list"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">list   &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of <a href="Thread.html">Thread</a> objects for all
threads that are either runnable or stopped.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span>(<span class="ruby-value">200</span>) }
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-value">1000000</span>.<span class="ruby-identifier">times</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span> } }
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">stop</span> }
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">list</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">t</span>}
</pre>

<p>This will produce:</p>

<pre class="ruby"><span class="ruby-comment">#&lt;Thread:0x401b3e84 sleep&gt;</span>
<span class="ruby-comment">#&lt;Thread:0x401b3f38 run&gt;</span>
<span class="ruby-comment">#&lt;Thread:0x401b3fb0 sleep&gt;</span>
<span class="ruby-comment">#&lt;Thread:0x401bdf4c run&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="list-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_thread_list(void)
{
    VALUE ary = rb_ary_new();
    rb_vm_t *vm = GET_THREAD()-&gt;vm;
    rb_thread_t *th = 0;

    list_for_each(&amp;vm-&gt;living_threads, th, vmlt_node) {
        switch (th-&gt;status) {
          case THREAD_RUNNABLE:
          case THREAD_STOPPED:
          case THREAD_STOPPED_FOREVER:
            rb_ary_push(ary, th-&gt;self);
          default:
            break;
        }
    }
    return ary;
}
            </pre> 
            </div><!-- list-source -->
            
          </div>

          

          
        </div><!-- list-method -->
      
        <div id="main-method" class="method-detail ">
          <a name="method-c-main"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">main   &rarr; thread</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the main thread.</p>
            

            
            <div class="method-source-code" id="main-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_s_main(VALUE klass)
{
    return rb_thread_main();
}
            </pre> 
            </div><!-- main-source -->
            
          </div>

          

          
        </div><!-- main-method -->
      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new { ... }                  &rarr; thread</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(*args, &proc)            &rarr; thread</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(*args) { |args| ... }    &rarr; thread</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new thread executing the given block.</p>

<p>Any <code>args</code> given to <a href="Thread.html#method-c-new">::new</a>
will be passed to the block:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = []
<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span> = <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>,<span class="ruby-identifier">c</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">d</span>,<span class="ruby-identifier">e</span>,<span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">arr</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">e</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">f</span> }.<span class="ruby-identifier">join</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>

<p>A <a href="ThreadError.html">ThreadError</a> exception is raised if <a
href="Thread.html#method-c-new">::new</a> is called without a block.</p>

<p>If you’re going to subclass <a href="Thread.html">Thread</a>, be sure to
call super in your <code>initialize</code> method, otherwise a <a
href="ThreadError.html">ThreadError</a> will be raised.</p>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_s_new(int argc, VALUE *argv, VALUE klass)
{
    rb_thread_t *th;
    VALUE thread = rb_thread_alloc(klass);

    if (GET_VM()-&gt;main_thread-&gt;status == THREAD_KILLED)
        rb_raise(rb_eThreadError, &quot;can't alloc thread&quot;);

    rb_obj_call_init(thread, argc, argv);
    GetThreadPtr(thread, th);
    if (!th-&gt;first_args) {
        rb_raise(rb_eThreadError, &quot;uninitialized thread - check `%s#initialize'&quot;,
                 rb_class2name(klass));
    }
    return thread;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
        <div id="pass-method" class="method-detail ">
          <a name="method-c-pass"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pass   &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Give the thread scheduler a hint to pass execution to another thread. A
running thread may or may not switch, it depends on OS and processor.</p>
            

            
            <div class="method-source-code" id="pass-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_s_pass(VALUE klass)
{
    rb_thread_schedule();
    return Qnil;
}
            </pre> 
            </div><!-- pass-source -->
            
          </div>

          

          
        </div><!-- pass-method -->
      
        <div id="pending_interrupt-3F-method" class="method-detail ">
          <a name="method-c-pending_interrupt-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pending_interrupt?(error = nil) &rarr; true/false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns whether or not the asynchronous queue is empty.</p>

<p>Since <a
href="Thread.html#method-c-handle_interrupt">::handle_interrupt</a> can be
used to defer asynchronous events, this method can be used to determine if
there are any deferred events.</p>

<p>If you find this method returns true, then you may finish
<code>:never</code> blocks.</p>

<p>For example, the following method processes deferred asynchronous events
immediately.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">kick_interrupt_immediately</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">handle_interrupt</span>(<span class="ruby-constant">Object</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">immediate</span>) {
    <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">pass</span>
  }
<span class="ruby-keyword">end</span>
</pre>

<p>If <code>error</code> is given, then check only for <code>error</code> type
deferred events.</p>

<h3 id="method-c-pending_interrupt-3F-label-Usage">Usage<span><a href="#method-c-pending_interrupt-3F-label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre>th = Thread.new{
  Thread.handle_interrupt(RuntimeError =&gt; :on_blocking){
    while true
      ...
      # reach safe point to invoke interrupt
      if Thread.pending_interrupt?
        Thread.handle_interrupt(Object =&gt; :immediate){}
      end
      ...
    end
  }
}
...
th.raise # stop thread</pre>

<p>This example can also be written as the following, which you should use to
avoid asynchronous interrupts.</p>

<pre>flag = true
th = Thread.new{
  Thread.handle_interrupt(RuntimeError =&gt; :on_blocking){
    while true
      ...
      # reach safe point to invoke interrupt
      break if flag == false
      ...
    end
  }
}
...
flag = false # stop thread</pre>
            

            
            <div class="method-source-code" id="pending_interrupt-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_s_pending_interrupt_p(int argc, VALUE *argv, VALUE self)
{
    return rb_thread_pending_interrupt_p(argc, argv, GET_THREAD()-&gt;self);
}
            </pre> 
            </div><!-- pending_interrupt-3F-source -->
            
          </div>

          

          
        </div><!-- pending_interrupt-3F-method -->
      
        <div id="start-method" class="method-detail ">
          <a name="method-c-start"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">start([args]*) {|args| block }   &rarr; thread</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Basically the same as <a href="Thread.html#method-c-new">::new</a>.
However, if class <a href="Thread.html">Thread</a> is subclassed, then
calling <code>start</code> in that subclass will not invoke the subclass’s
<code>initialize</code> method.</p>
            

            
            <div class="method-source-code" id="start-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_start(VALUE klass, VALUE args)
{
    return thread_create_core(rb_thread_alloc(klass), args, 0);
}
            </pre> 
            </div><!-- start-source -->
            
          </div>

          

          
        </div><!-- start-method -->
      
        <div id="stop-method" class="method-detail ">
          <a name="method-c-stop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">stop   &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Stops execution of the current thread, putting it into a “sleep” state, and
schedules execution of another thread.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;a&quot;</span>; <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">stop</span>; <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;c&quot;</span> }
<span class="ruby-identifier">sleep</span> <span class="ruby-value">0.1</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">status!</span>=<span class="ruby-string">'sleep'</span>
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;b&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">run</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">join</span>
<span class="ruby-comment">#=&gt; &quot;abc&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="stop-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_thread_stop(void)
{
    if (rb_thread_alone()) {
        rb_raise(rb_eThreadError,
                 &quot;stopping only thread\n\tnote: use sleep to stop forever&quot;);
    }
    rb_thread_sleep_deadly();
    return Qnil;
}
            </pre> 
            </div><!-- stop-source -->
            
          </div>

          

          
        </div><!-- stop-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">thr[sym]   &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Attribute Reference—Returns the value of a fiber-local variable (current
thread’s root fiber if not explicitly inside a <a
href="Fiber.html">Fiber</a>), using either a symbol or a string name. If
the specified variable does not exist, returns <code>nil</code>.</p>

<pre class="ruby">[
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[<span class="ruby-string">&quot;name&quot;</span>] = <span class="ruby-string">&quot;A&quot;</span> },
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">name</span>]  = <span class="ruby-string">&quot;B&quot;</span> },
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[<span class="ruby-string">&quot;name&quot;</span>] = <span class="ruby-string">&quot;C&quot;</span> }
].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">th</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">th</span>.<span class="ruby-identifier">join</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{th.inspect}: #{th[:name]}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This will produce:</p>

<pre class="ruby"><span class="ruby-comment">#&lt;Thread:0x00000002a54220 dead&gt;: A</span>
<span class="ruby-comment">#&lt;Thread:0x00000002a541a8 dead&gt;: B</span>
<span class="ruby-comment">#&lt;Thread:0x00000002a54130 dead&gt;: C</span>
</pre>

<p><a href="Thread.html#method-i-5B-5D">#[]</a> and <a
href="Thread.html#method-i-5B-5D-3D">#[]=</a> are not thread-local but
fiber-local. This confusion did not exist in Ruby 1.8 because fibers are
only available since Ruby 1.9. Ruby 1.9 chooses that the methods behaves
fiber-local to save following idiom for dynamic scope.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">meth</span>(<span class="ruby-identifier">newvalue</span>)
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">oldvalue</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">name</span>]
    <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">name</span>] = <span class="ruby-identifier">newvalue</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">ensure</span>
    <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">name</span>] = <span class="ruby-identifier">oldvalue</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The idiom may not work as dynamic scope if the methods are thread-local and
a given block switches fiber.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">Fiber</span>.<span class="ruby-identifier">new</span> {
  <span class="ruby-identifier">meth</span>(<span class="ruby-value">1</span>) {
    <span class="ruby-constant">Fiber</span>.<span class="ruby-identifier">yield</span>
  }
}
<span class="ruby-identifier">meth</span>(<span class="ruby-value">2</span>) {
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">resume</span>
}
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">resume</span>
<span class="ruby-identifier">p</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">name</span>]
<span class="ruby-comment">#=&gt; nil if fiber-local</span>
<span class="ruby-comment">#=&gt; 2 if thread-local (The value 2 is leaked to outside of meth method.)</span>
</pre>

<p>For thread-local variables, please see <a
href="Thread.html#method-i-thread_variable_get">thread_variable_get</a> and
<a href="Thread.html#method-i-thread_variable_set">thread_variable_set</a>.</p>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_aref(VALUE thread, VALUE key)
{
    ID id = rb_check_id(&amp;key);
    if (!id) return Qnil;
    return rb_thread_local_aref(thread, id);
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">thr[sym] = obj   &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Attribute Assignment—Sets or creates the value of a fiber-local variable,
using either a symbol or a string.</p>

<p>See also <a href="Thread.html#method-i-5B-5D">#[]</a>.</p>

<p>For thread-local variables, please see <a
href="Thread.html#method-i-thread_variable_set">thread_variable_set</a> and
<a href="Thread.html#method-i-thread_variable_get">thread_variable_get</a>.</p>
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_aset(VALUE self, VALUE id, VALUE val)
{
    return rb_thread_local_aset(self, rb_to_id(id), val);
}
            </pre> 
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->
      
        <div id="abort_on_exception-method" class="method-detail ">
          <a name="method-i-abort_on_exception"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">abort_on_exception   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the status of the thread-local “abort on exception” condition for
this <code>thr</code>.</p>

<p>The default is <code>false</code>.</p>

<p>See also <a
href="Thread.html#method-i-abort_on_exception-3D">abort_on_exception=</a>.</p>

<p>There is also a class level method to set this for all threads, see <a
href="Thread.html#method-c-abort_on_exception">::abort_on_exception</a>.</p>
            

            
            <div class="method-source-code" id="abort_on_exception-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_abort_exc(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);
    return th-&gt;abort_on_exception ? Qtrue : Qfalse;
}
            </pre> 
            </div><!-- abort_on_exception-source -->
            
          </div>

          

          
        </div><!-- abort_on_exception-method -->
      
        <div id="abort_on_exception-3D-method" class="method-detail ">
          <a name="method-i-abort_on_exception-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">abort_on_exception= boolean   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>When set to <code>true</code>, all threads (including the main program)
will abort if an exception is raised in this <code>thr</code>.</p>

<p>The process will effectively <code>exit(0)</code>.</p>

<p>See also <a
href="Thread.html#method-i-abort_on_exception">abort_on_exception</a>.</p>

<p>There is also a class level method to set this for all threads, see <a
href="Thread.html#method-c-abort_on_exception-3D">::abort_on_exception=</a>.</p>
            

            
            <div class="method-source-code" id="abort_on_exception-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_abort_exc_set(VALUE thread, VALUE val)
{
    rb_thread_t *th;

    GetThreadPtr(thread, th);
    th-&gt;abort_on_exception = RTEST(val);
    return val;
}
            </pre> 
            </div><!-- abort_on_exception-3D-source -->
            
          </div>

          

          
        </div><!-- abort_on_exception-3D-method -->
      
        <div id="add_trace_func-method" class="method-detail ">
          <a name="method-i-add_trace_func"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">add_trace_func(proc)    &rarr; proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Adds <em>proc</em> as a handler for tracing.</p>

<p>See <a href="Thread.html#method-i-set_trace_func">#set_trace_func</a> and
<a href="Kernel.html#method-i-set_trace_func">Kernel#set_trace_func</a>.</p>
            

            
            <div class="method-source-code" id="add_trace_func-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_add_trace_func_m(VALUE obj, VALUE trace)
{
    rb_thread_t *th;

    GetThreadPtr(obj, th);
    thread_add_trace_func(th, trace);
    return trace;
}
            </pre> 
            </div><!-- add_trace_func-source -->
            
          </div>

          

          
        </div><!-- add_trace_func-method -->
      
        <div id="alive-3F-method" class="method-detail ">
          <a name="method-i-alive-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">alive?   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <code>thr</code> is running or sleeping.</p>

<pre class="ruby"><span class="ruby-identifier">thr</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { }
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">join</span>                <span class="ruby-comment">#=&gt; #&lt;Thread:0x401b3fb0 dead&gt;</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">alive?</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">alive?</span>              <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>See also <a href="Thread.html#method-i-stop-3F">stop?</a> and <a
href="Thread.html#method-i-status">status</a>.</p>
            

            
            <div class="method-source-code" id="alive-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_alive_p(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);

    if (rb_threadptr_dead(th))
        return Qfalse;
    return Qtrue;
}
            </pre> 
            </div><!-- alive-3F-source -->
            
          </div>

          

          
        </div><!-- alive-3F-method -->
      
        <div id="backtrace-method" class="method-detail ">
          <a name="method-i-backtrace"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">backtrace    &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current backtrace of the target thread.</p>
            

            
            <div class="method-source-code" id="backtrace-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_backtrace_m(int argc, VALUE *argv, VALUE thval)
{
    return rb_vm_thread_backtrace(argc, argv, thval);
}
            </pre> 
            </div><!-- backtrace-source -->
            
          </div>

          

          
        </div><!-- backtrace-method -->
      
        <div id="backtrace_locations-method" class="method-detail ">
          <a name="method-i-backtrace_locations"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">backtrace_locations(*args)   &rarr; array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the execution stack for the target thread—an array containing
backtrace location objects.</p>

<p>See <a
href="Thread/Backtrace/Location.html">Thread::Backtrace::Location</a> for
more information.</p>

<p>This method behaves similarly to <a
href="Kernel.html#method-i-caller_locations">Kernel#caller_locations</a>
except it applies to a specific thread.</p>
            

            
            <div class="method-source-code" id="backtrace_locations-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_backtrace_locations_m(int argc, VALUE *argv, VALUE thval)
{
    return rb_vm_thread_backtrace_locations(argc, argv, thval);
}
            </pre> 
            </div><!-- backtrace_locations-source -->
            
          </div>

          

          
        </div><!-- backtrace_locations-method -->
      
        <div id="exit-method" class="method-detail ">
          <a name="method-i-exit"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">exit        &rarr; thr or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">kill        &rarr; thr or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">terminate   &rarr; thr or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Terminates <code>thr</code> and schedules another thread to be run.</p>

<p>If this thread is already marked to be killed, <a
href="Thread.html#method-i-exit">exit</a> returns the <a
href="Thread.html">Thread</a>.</p>

<p>If this is the main thread, or the last thread, exits the process.</p>
            

            
            <div class="method-source-code" id="exit-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_thread_kill(VALUE thread)
{
    rb_thread_t *th;

    GetThreadPtr(thread, th);

    if (th-&gt;to_kill || th-&gt;status == THREAD_KILLED) {
        return thread;
    }
    if (th == th-&gt;vm-&gt;main_thread) {
        rb_exit(EXIT_SUCCESS);
    }

    thread_debug(&quot;rb_thread_kill: %p (%&quot;PRI_THREAD_ID&quot;)\n&quot;, (void *)th, thread_id_str(th));

    if (th == GET_THREAD()) {
        /* kill myself immediately */
        rb_threadptr_to_kill(th);
    }
    else {
        rb_threadptr_pending_interrupt_enque(th, eKillSignal);
        rb_threadptr_interrupt(th);
    }
    return thread;
}
            </pre> 
            </div><!-- exit-source -->
            
          </div>

          

          
        </div><!-- exit-method -->
      
        <div id="group-method" class="method-detail ">
          <a name="method-i-group"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">group   &rarr; thgrp or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <a href="ThreadGroup.html">ThreadGroup</a> which contains the
given thread, or returns <code>nil</code> if <code>thr</code> is not a
member of any group.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">main</span>.<span class="ruby-identifier">group</span>   <span class="ruby-comment">#=&gt; #&lt;ThreadGroup:0x4029d914&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="group-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_thread_group(VALUE thread)
{
    rb_thread_t *th;
    VALUE group;
    GetThreadPtr(thread, th);
    group = th-&gt;thgroup;

    if (!group) {
        group = Qnil;
    }
    return group;
}
            </pre> 
            </div><!-- group-source -->
            
          </div>

          

          
        </div><!-- group-method -->
      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inspect   &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Dump the name, id, and status of <em>thr</em> to a string.</p>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_inspect(VALUE thread)
{
    return rb_thread_inspect_msg(thread, 1, 1, 1);
}
            </pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->
      
        <div id="join-method" class="method-detail ">
          <a name="method-i-join"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">join          &rarr; thr</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">join(limit)   &rarr; thr</span>
            
          </div>
          
          
          <div>
  
            
            <p>The calling thread will suspend execution and run this <code>thr</code>.</p>

<p>Does not return until <code>thr</code> exits or until the given
<code>limit</code> seconds have passed.</p>

<p>If the time limit expires, <code>nil</code> will be returned, otherwise
<code>thr</code> is returned.</p>

<p>Any threads not joined will be killed when the main program exits.</p>

<p>If <code>thr</code> had previously raised an exception and the <a
href="Thread.html#method-c-abort_on_exception">::abort_on_exception</a> or
$DEBUG flags are not set, (so the exception has not yet been processed), it
will be processed at this time.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;a&quot;</span>; <span class="ruby-identifier">sleep</span>(<span class="ruby-value">10</span>); <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;b&quot;</span>; <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;c&quot;</span> }
<span class="ruby-identifier">x</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;x&quot;</span>; <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">pass</span>; <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;y&quot;</span>; <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;z&quot;</span> }
<span class="ruby-identifier">x</span>.<span class="ruby-identifier">join</span> <span class="ruby-comment"># Let thread x finish, thread a will be killed on exit.</span>
<span class="ruby-comment">#=&gt; &quot;axyz&quot;</span>
</pre>

<p>The following example illustrates the <code>limit</code> parameter.</p>

<pre class="ruby"><span class="ruby-identifier">y</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-value">4</span>.<span class="ruby-identifier">times</span> { <span class="ruby-identifier">sleep</span> <span class="ruby-value">0.1</span>; <span class="ruby-identifier">puts</span> <span class="ruby-string">'tick... '</span> }}
<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Waiting&quot;</span> <span class="ruby-keyword">until</span> <span class="ruby-identifier">y</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value">0.15</span>)
</pre>

<p>This will produce:</p>

<pre>tick...
Waiting
tick...
Waiting
tick...
tick...</pre>
            

            
            <div class="method-source-code" id="join-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_join_m(int argc, VALUE *argv, VALUE self)
{
    rb_thread_t *target_th;
    double delay = DELAY_INFTY;
    VALUE limit;

    GetThreadPtr(self, target_th);

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;limit);
    if (!NIL_P(limit)) {
        delay = rb_num2dbl(limit);
    }

    return thread_join(target_th, delay);
}
            </pre> 
            </div><!-- join-source -->
            
          </div>

          

          
        </div><!-- join-method -->
      
        <div id="key-3F-method" class="method-detail ">
          <a name="method-i-key-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">key?(sym)   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the given string (or symbol) exists as a
fiber-local variable.</p>

<pre class="ruby"><span class="ruby-identifier">me</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>
<span class="ruby-identifier">me</span>[:<span class="ruby-identifier">oliver</span>] = <span class="ruby-string">&quot;a&quot;</span>
<span class="ruby-identifier">me</span>.<span class="ruby-identifier">key?</span>(:<span class="ruby-identifier">oliver</span>)    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">me</span>.<span class="ruby-identifier">key?</span>(:<span class="ruby-identifier">stanley</span>)   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="key-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_key_p(VALUE self, VALUE key)
{
    rb_thread_t *th;
    ID id = rb_check_id(&amp;key);

    GetThreadPtr(self, th);

    if (!id || !th-&gt;local_storage) {
        return Qfalse;
    }
    if (st_lookup(th-&gt;local_storage, id, 0)) {
        return Qtrue;
    }
    return Qfalse;
}
            </pre> 
            </div><!-- key-3F-source -->
            
          </div>

          

          
        </div><!-- key-3F-method -->
      
        <div id="keys-method" class="method-detail ">
          <a name="method-i-keys"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">keys   &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of the names of the fiber-local variables (as Symbols).</p>

<pre class="ruby"><span class="ruby-identifier">thr</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">cat</span>] = <span class="ruby-string">'meow'</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[<span class="ruby-string">&quot;dog&quot;</span>] = <span class="ruby-string">'woof'</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">join</span>   <span class="ruby-comment">#=&gt; #&lt;Thread:0x401b3f10 dead&gt;</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">keys</span>   <span class="ruby-comment">#=&gt; [:dog, :cat]</span>
</pre>
            

            
            <div class="method-source-code" id="keys-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_keys(VALUE self)
{
    rb_thread_t *th;
    VALUE ary = rb_ary_new();
    GetThreadPtr(self, th);

    if (th-&gt;local_storage) {
        st_foreach(th-&gt;local_storage, thread_keys_i, ary);
    }
    return ary;
}
            </pre> 
            </div><!-- keys-source -->
            
          </div>

          

          
        </div><!-- keys-method -->
      
        <div id="kill-method" class="method-detail ">
          <a name="method-i-kill"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">exit        &rarr; thr or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">kill        &rarr; thr or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">terminate   &rarr; thr or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Terminates <code>thr</code> and schedules another thread to be run.</p>

<p>If this thread is already marked to be killed, <a
href="Thread.html#method-i-exit">exit</a> returns the <a
href="Thread.html">Thread</a>.</p>

<p>If this is the main thread, or the last thread, exits the process.</p>
            

            
            <div class="method-source-code" id="kill-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_thread_kill(VALUE thread)
{
    rb_thread_t *th;

    GetThreadPtr(thread, th);

    if (th-&gt;to_kill || th-&gt;status == THREAD_KILLED) {
        return thread;
    }
    if (th == th-&gt;vm-&gt;main_thread) {
        rb_exit(EXIT_SUCCESS);
    }

    thread_debug(&quot;rb_thread_kill: %p (%&quot;PRI_THREAD_ID&quot;)\n&quot;, (void *)th, thread_id_str(th));

    if (th == GET_THREAD()) {
        /* kill myself immediately */
        rb_threadptr_to_kill(th);
    }
    else {
        rb_threadptr_pending_interrupt_enque(th, eKillSignal);
        rb_threadptr_interrupt(th);
    }
    return thread;
}
            </pre> 
            </div><!-- kill-source -->
            
          </div>

          

          
        </div><!-- kill-method -->
      
        <div id="pending_interrupt-3F-method" class="method-detail ">
          <a name="method-i-pending_interrupt-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pending_interrupt?(error = nil) &rarr; true/false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns whether or not the asynchronous queue is empty for the target
thread.</p>

<p>If <code>error</code> is given, then check only for <code>error</code> type
deferred events.</p>

<p>See <a
href="Thread.html#method-c-pending_interrupt-3F">::pending_interrupt?</a>
for more information.</p>
            

            
            <div class="method-source-code" id="pending_interrupt-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_pending_interrupt_p(int argc, VALUE *argv, VALUE target_thread)
{
    rb_thread_t *target_th;

    GetThreadPtr(target_thread, target_th);

    if (rb_threadptr_pending_interrupt_empty_p(target_th)) {
        return Qfalse;
    }
    else {
        if (argc == 1) {
            VALUE err;
            rb_scan_args(argc, argv, &quot;01&quot;, &amp;err);
            if (!rb_obj_is_kind_of(err, rb_cModule)) {
                rb_raise(rb_eTypeError, &quot;class or module required for rescue clause&quot;);
            }
            if (rb_threadptr_pending_interrupt_include_p(target_th, err)) {
                return Qtrue;
            }
            else {
                return Qfalse;
            }
        }
        return Qtrue;
    }
}
            </pre> 
            </div><!-- pending_interrupt-3F-source -->
            
          </div>

          

          
        </div><!-- pending_interrupt-3F-method -->
      
        <div id="priority-method" class="method-detail ">
          <a name="method-i-priority"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">priority   &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the priority of <em>thr</em>. Default is inherited from the current
thread which creating the new thread, or zero for the initial main thread;
higher-priority thread will run more frequently than lower-priority threads
(but lower-priority threads can also run).</p>

<p>This is just hint for Ruby thread scheduler.  It may be ignored on some
platform.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">priority</span>   <span class="ruby-comment">#=&gt; 0</span>
</pre>
            

            
            <div class="method-source-code" id="priority-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_priority(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);
    return INT2NUM(th-&gt;priority);
}
            </pre> 
            </div><!-- priority-source -->
            
          </div>

          

          
        </div><!-- priority-method -->
      
        <div id="priority-3D-method" class="method-detail ">
          <a name="method-i-priority-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">priority= integer   &rarr; thr</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the priority of <em>thr</em> to <em>integer</em>. Higher-priority
threads will run more frequently than lower-priority threads (but
lower-priority threads can also run).</p>

<p>This is just hint for Ruby thread scheduler.  It may be ignored on some
platform.</p>

<pre class="ruby"><span class="ruby-identifier">count1</span> = <span class="ruby-identifier">count2</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">loop</span> { <span class="ruby-identifier">count1</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> }
    <span class="ruby-keyword">end</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">priority</span> = <span class="ruby-value">-1</span>

<span class="ruby-identifier">b</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">loop</span> { <span class="ruby-identifier">count2</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> }
    <span class="ruby-keyword">end</span>
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">priority</span> = <span class="ruby-value">-2</span>
<span class="ruby-identifier">sleep</span> <span class="ruby-value">1</span>   <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">count1</span>    <span class="ruby-comment">#=&gt; 622504</span>
<span class="ruby-identifier">count2</span>    <span class="ruby-comment">#=&gt; 5832</span>
</pre>
            

            
            <div class="method-source-code" id="priority-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_priority_set(VALUE thread, VALUE prio)
{
    rb_thread_t *th;
    int priority;
    GetThreadPtr(thread, th);


#if USE_NATIVE_THREAD_PRIORITY
    th-&gt;priority = NUM2INT(prio);
    native_thread_apply_priority(th);
#else
    priority = NUM2INT(prio);
    if (priority &gt; RUBY_THREAD_PRIORITY_MAX) {
        priority = RUBY_THREAD_PRIORITY_MAX;
    }
    else if (priority &lt; RUBY_THREAD_PRIORITY_MIN) {
        priority = RUBY_THREAD_PRIORITY_MIN;
    }
    th-&gt;priority = priority;
#endif
    return INT2NUM(th-&gt;priority);
}
            </pre> 
            </div><!-- priority-3D-source -->
            
          </div>

          

          
        </div><!-- priority-3D-method -->
      
        <div id="raise-method" class="method-detail ">
          <a name="method-i-raise"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">raise</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">raise(string)</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">raise(exception [, string [, array]])</span>
            
          </div>
          
          
          <div>
  
            
            <p>Raises an exception from the given thread. The caller does not have to be
<code>thr</code>. See <a href="Kernel.html#method-i-raise">Kernel#raise</a>
for more information.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">abort_on_exception</span> = <span class="ruby-keyword">true</span>
<span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span>(<span class="ruby-value">200</span>) }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">raise</span>(<span class="ruby-string">&quot;Gotcha&quot;</span>)
</pre>

<p>This will produce:</p>

<pre>prog.rb:3: Gotcha (RuntimeError)
 from prog.rb:2:in `initialize'
 from prog.rb:2:in `new'
 from prog.rb:2</pre>
            

            
            <div class="method-source-code" id="raise-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_raise_m(int argc, VALUE *argv, VALUE self)
{
    rb_thread_t *target_th;
    rb_thread_t *th = GET_THREAD();
    GetThreadPtr(self, target_th);
    rb_threadptr_raise(target_th, argc, argv);

    /* To perform Thread.current.raise as Kernel.raise */
    if (th == target_th) {
        RUBY_VM_CHECK_INTS(th);
    }
    return Qnil;
}
            </pre> 
            </div><!-- raise-source -->
            
          </div>

          

          
        </div><!-- raise-method -->
      
        <div id="run-method" class="method-detail ">
          <a name="method-i-run"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">run   &rarr; thr</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Wakes up <code>thr</code>, making it eligible for scheduling.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;a&quot;</span>; <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">stop</span>; <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;c&quot;</span> }
<span class="ruby-identifier">sleep</span> <span class="ruby-value">0.1</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">status!</span>=<span class="ruby-string">'sleep'</span>
<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Got here&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">run</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">join</span>
</pre>

<p>This will produce:</p>

<pre class="ruby"><span class="ruby-identifier">a</span>
<span class="ruby-constant">Got</span> <span class="ruby-identifier">here</span>
<span class="ruby-identifier">c</span>
</pre>

<p>See also the instance method <a
href="Thread.html#method-i-wakeup">wakeup</a>.</p>
            

            
            <div class="method-source-code" id="run-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_thread_run(VALUE thread)
{
    rb_thread_wakeup(thread);
    rb_thread_schedule();
    return thread;
}
            </pre> 
            </div><!-- run-source -->
            
          </div>

          

          
        </div><!-- run-method -->
      
        <div id="safe_level-method" class="method-detail ">
          <a name="method-i-safe_level"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">safe_level   &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the safe level in effect for <em>thr</em>. Setting thread-local
safe levels can help when implementing sandboxes which run insecure code.</p>

<pre class="ruby"><span class="ruby-identifier">thr</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">$SAFE</span> = <span class="ruby-value">3</span>; <span class="ruby-identifier">sleep</span> }
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">safe_level</span>   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">safe_level</span>              <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="safe_level-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_safe_level(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);

    return INT2NUM(th-&gt;safe_level);
}
            </pre> 
            </div><!-- safe_level-source -->
            
          </div>

          

          
        </div><!-- safe_level-method -->
      
        <div id="set_trace_func-method" class="method-detail ">
          <a name="method-i-set_trace_func"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">set_trace_func(proc)    &rarr; proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">set_trace_func(nil)     &rarr; nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Establishes <em>proc</em> on <em>thr</em> as the handler for tracing, or
disables tracing if the parameter is <code>nil</code>.</p>

<p>See <a
href="Kernel.html#method-i-set_trace_func">Kernel#set_trace_func</a>.</p>
            

            
            <div class="method-source-code" id="set_trace_func-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_set_trace_func_m(VALUE obj, VALUE trace)
{
    rb_thread_t *th;

    GetThreadPtr(obj, th);
    rb_threadptr_remove_event_hook(th, call_trace_func, Qundef);

    if (NIL_P(trace)) {
        return Qnil;
    }

    thread_add_trace_func(th, trace);
    return trace;
}
            </pre> 
            </div><!-- set_trace_func-source -->
            
          </div>

          

          
        </div><!-- set_trace_func-method -->
      
        <div id="status-method" class="method-detail ">
          <a name="method-i-status"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">status   &rarr; string, false or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the status of <code>thr</code>.</p>
<dl class="rdoc-list label-list"><dt><code>&quot;sleep&quot;</code>
<dd>
<p>Returned if this thread is sleeping or waiting on I/O</p>
</dd><dt><code>&quot;run&quot;</code>
<dd>
<p>When this thread is executing</p>
</dd><dt><code>&quot;aborting&quot;</code>
<dd>
<p>If this thread is aborting</p>
</dd><dt><code>false</code>
<dd>
<p>When this thread is terminated normally</p>
</dd><dt><code>nil</code>
<dd>
<p>If terminated with an exception.</p>
</dd></dl>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">raise</span>(<span class="ruby-string">&quot;die now&quot;</span>) }
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">stop</span> }
<span class="ruby-identifier">c</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">exit</span> }
<span class="ruby-identifier">d</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span> }
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">kill</span>                  <span class="ruby-comment">#=&gt; #&lt;Thread:0x401b3678 aborting&gt;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">status</span>                <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">status</span>                <span class="ruby-comment">#=&gt; &quot;sleep&quot;</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">status</span>                <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">status</span>                <span class="ruby-comment">#=&gt; &quot;aborting&quot;</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">status</span>   <span class="ruby-comment">#=&gt; &quot;run&quot;</span>
</pre>

<p>See also the instance methods <a
href="Thread.html#method-i-alive-3F">alive?</a> and <a
href="Thread.html#method-i-stop-3F">stop?</a></p>
            

            
            <div class="method-source-code" id="status-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_status(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);

    if (rb_threadptr_dead(th)) {
        if (!NIL_P(th-&gt;errinfo) &amp;&amp; !FIXNUM_P(th-&gt;errinfo)
            /* TODO */ ) {
            return Qnil;
        }
        return Qfalse;
    }
    return rb_str_new2(thread_status_name(th));
}
            </pre> 
            </div><!-- status-source -->
            
          </div>

          

          
        </div><!-- status-method -->
      
        <div id="stop-3F-method" class="method-detail ">
          <a name="method-i-stop-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">stop?   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <code>thr</code> is dead or sleeping.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">stop</span> }
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">stop?</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">stop?</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>See also <a href="Thread.html#method-i-alive-3F">alive?</a> and <a
href="Thread.html#method-i-status">status</a>.</p>
            

            
            <div class="method-source-code" id="stop-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_stop_p(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);

    if (rb_threadptr_dead(th))
        return Qtrue;
    if (th-&gt;status == THREAD_STOPPED || th-&gt;status == THREAD_STOPPED_FOREVER)
        return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- stop-3F-source -->
            
          </div>

          

          
        </div><!-- stop-3F-method -->
      
        <div id="terminate-method" class="method-detail ">
          <a name="method-i-terminate"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">terminate   &rarr; thr or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Terminates <code>thr</code> and schedules another thread to be run.</p>

<p>If this thread is already marked to be killed, <a
href="Thread.html#method-i-exit">exit</a> returns the <a
href="Thread.html">Thread</a>.</p>

<p>If this is the main thread, or the last thread, exits the process.</p>
            

            
            <div class="method-source-code" id="terminate-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_thread_kill(VALUE thread)
{
    rb_thread_t *th;

    GetThreadPtr(thread, th);

    if (th-&gt;to_kill || th-&gt;status == THREAD_KILLED) {
        return thread;
    }
    if (th == th-&gt;vm-&gt;main_thread) {
        rb_exit(EXIT_SUCCESS);
    }

    thread_debug(&quot;rb_thread_kill: %p (%&quot;PRI_THREAD_ID&quot;)\n&quot;, (void *)th, thread_id_str(th));

    if (th == GET_THREAD()) {
        /* kill myself immediately */
        rb_threadptr_to_kill(th);
    }
    else {
        rb_threadptr_pending_interrupt_enque(th, eKillSignal);
        rb_threadptr_interrupt(th);
    }
    return thread;
}
            </pre> 
            </div><!-- terminate-source -->
            
          </div>

          

          
        </div><!-- terminate-method -->
      
        <div id="thread_variable-3F-method" class="method-detail ">
          <a name="method-i-thread_variable-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">thread_variable?(key)   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the given string (or symbol) exists as a
thread-local variable.</p>

<pre class="ruby"><span class="ruby-identifier">me</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>
<span class="ruby-identifier">me</span>.<span class="ruby-identifier">thread_variable_set</span>(:<span class="ruby-identifier">oliver</span>, <span class="ruby-string">&quot;a&quot;</span>)
<span class="ruby-identifier">me</span>.<span class="ruby-identifier">thread_variable?</span>(:<span class="ruby-identifier">oliver</span>)    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">me</span>.<span class="ruby-identifier">thread_variable?</span>(:<span class="ruby-identifier">stanley</span>)   <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>Note that these are not fiber local variables.  Please see <a
href="Thread.html#method-i-5B-5D">#[]</a> and <a
href="Thread.html#method-i-thread_variable_get">#thread_variable_get</a>
for more details.</p>
            

            
            <div class="method-source-code" id="thread_variable-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_variable_p(VALUE thread, VALUE key)
{
    VALUE locals;
    ID id = rb_check_id(&amp;key);

    if (!id) return Qfalse;

    locals = rb_ivar_get(thread, id_locals);

    if (!RHASH(locals)-&gt;ntbl)
        return Qfalse;

    if (st_lookup(RHASH(locals)-&gt;ntbl, ID2SYM(id), 0)) {
        return Qtrue;
    }

    return Qfalse;
}
            </pre> 
            </div><!-- thread_variable-3F-source -->
            
          </div>

          

          
        </div><!-- thread_variable-3F-method -->
      
        <div id="thread_variable_get-method" class="method-detail ">
          <a name="method-i-thread_variable_get"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">thread_variable_get(key)  &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the value of a thread local variable that has been set.  Note that
these are different than fiber local values.  For fiber local values,
please see <a href="Thread.html#method-i-5B-5D">#[]</a> and <a
href="Thread.html#method-i-5B-5D-3D">#[]=</a>.</p>

<p><a href="Thread.html">Thread</a> local values are carried along with
threads, and do not respect fibers.  For example:</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">thread_variable_set</span>(<span class="ruby-string">&quot;foo&quot;</span>, <span class="ruby-string">&quot;bar&quot;</span>) <span class="ruby-comment"># set a thread local</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[<span class="ruby-string">&quot;foo&quot;</span>] = <span class="ruby-string">&quot;bar&quot;</span>                    <span class="ruby-comment"># set a fiber local</span>

  <span class="ruby-constant">Fiber</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-constant">Fiber</span>.<span class="ruby-identifier">yield</span> [
      <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">thread_variable_get</span>(<span class="ruby-string">&quot;foo&quot;</span>), <span class="ruby-comment"># get the thread local</span>
      <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[<span class="ruby-string">&quot;foo&quot;</span>],                     <span class="ruby-comment"># get the fiber local</span>
    ]
  }.<span class="ruby-identifier">resume</span>
}.<span class="ruby-identifier">join</span>.<span class="ruby-identifier">value</span> <span class="ruby-comment"># =&gt; ['bar', nil]</span>
</pre>

<p>The value “bar” is returned for the thread local, where nil is returned for
the fiber local.  The fiber is executed in the same thread, so the thread
local values are available.</p>
            

            
            <div class="method-source-code" id="thread_variable_get-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_variable_get(VALUE thread, VALUE key)
{
    VALUE locals;
    ID id = rb_check_id(&amp;key);

    if (!id) return Qnil;
    locals = rb_ivar_get(thread, id_locals);
    return rb_hash_aref(locals, ID2SYM(id));
}
            </pre> 
            </div><!-- thread_variable_get-source -->
            
          </div>

          

          
        </div><!-- thread_variable_get-method -->
      
        <div id="thread_variable_set-method" class="method-detail ">
          <a name="method-i-thread_variable_set"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">thread_variable_set(key, value)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets a thread local with <code>key</code> to <code>value</code>.  Note that
these are local to threads, and not to fibers.  Please see <a
href="Thread.html#method-i-thread_variable_get">#thread_variable_get</a>
and <a href="Thread.html#method-i-5B-5D">#[]</a> for more information.</p>
            

            
            <div class="method-source-code" id="thread_variable_set-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_variable_set(VALUE thread, VALUE id, VALUE val)
{
    VALUE locals;

    if (OBJ_FROZEN(thread)) {
        rb_error_frozen(&quot;thread locals&quot;);
    }

    locals = rb_ivar_get(thread, id_locals);
    return rb_hash_aset(locals, rb_to_symbol(id), val);
}
            </pre> 
            </div><!-- thread_variable_set-source -->
            
          </div>

          

          
        </div><!-- thread_variable_set-method -->
      
        <div id="thread_variables-method" class="method-detail ">
          <a name="method-i-thread_variables"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">thread_variables   &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of the names of the thread-local variables (as Symbols).</p>

<pre class="ruby"><span class="ruby-identifier">thr</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">thread_variable_set</span>(:<span class="ruby-identifier">cat</span>, <span class="ruby-string">'meow'</span>)
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">thread_variable_set</span>(<span class="ruby-string">&quot;dog&quot;</span>, <span class="ruby-string">'woof'</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">join</span>               <span class="ruby-comment">#=&gt; #&lt;Thread:0x401b3f10 dead&gt;</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">thread_variables</span>   <span class="ruby-comment">#=&gt; [:dog, :cat]</span>
</pre>

<p>Note that these are not fiber local variables.  Please see <a
href="Thread.html#method-i-5B-5D">#[]</a> and <a
href="Thread.html#method-i-thread_variable_get">#thread_variable_get</a>
for more details.</p>
            

            
            <div class="method-source-code" id="thread_variables-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_thread_variables(VALUE thread)
{
    VALUE locals;
    VALUE ary;

    locals = rb_ivar_get(thread, id_locals);
    ary = rb_ary_new();
    rb_hash_foreach(locals, keys_i, ary);

    return ary;
}
            </pre> 
            </div><!-- thread_variables-source -->
            
          </div>

          

          
        </div><!-- thread_variables-method -->
      
        <div id="value-method" class="method-detail ">
          <a name="method-i-value"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">value   &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Waits for <code>thr</code> to complete, using <a
href="Thread.html#method-i-join">join</a>, and returns its value.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">value</span>   <span class="ruby-comment">#=&gt; 4</span>
</pre>
            

            
            <div class="method-source-code" id="value-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
thread_value(VALUE self)
{
    rb_thread_t *th;
    GetThreadPtr(self, th);
    thread_join(th, DELAY_INFTY);
    return th-&gt;value;
}
            </pre> 
            </div><!-- value-source -->
            
          </div>

          

          
        </div><!-- value-method -->
      
        <div id="wakeup-method" class="method-detail ">
          <a name="method-i-wakeup"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">wakeup   &rarr; thr</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Marks a given thread as eligible for scheduling, however it may still
remain blocked on I/O.</p>

<p><strong>Note:</strong> This does not invoke the scheduler, see <a
href="Thread.html#method-i-run">run</a> for more information.</p>

<pre class="ruby"><span class="ruby-identifier">c</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">stop</span>; <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;hey!&quot;</span> }
<span class="ruby-identifier">sleep</span> <span class="ruby-value">0.1</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">status!</span>=<span class="ruby-string">'sleep'</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">wakeup</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">join</span>
<span class="ruby-comment">#=&gt; &quot;hey!&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="wakeup-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_thread_wakeup(VALUE thread)
{
    if (!RTEST(rb_thread_wakeup_alive(thread))) {
        rb_raise(rb_eThreadError, &quot;killed thread&quot;);
    }
    return thread;
}
            </pre> 
            </div><!-- wakeup-source -->
            
          </div>

          

          
        </div><!-- wakeup-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_Thread_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Thread_versioned").load("/associated/2.2.0/Thread.ihtml");</script> <div id='tx_Thread' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Thread").load("/associated/Thread.ihtml");</script> 
      
  <!-- dsqus ? -->
     

  
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
          

      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 2.2.0</small></p> 
  
   <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is a service of <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>, a <a href="http://neurogami.com">software development company in Scottsdale, AZ</a>.  <div class='oio-inline'><ins data-revive-zoneid="1" data-revive-id="58924a5717c091dfee6dda3f7d38c4d7"></ins><script async src="//ras.ruby-doc.org/vvv/delivery/thesinkjs.php"></script></div></p>
 
       <p><small>Generated with Ruby-doc Rdoc Generator 0.39.0</small>.</p>
  </div>
</div>
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-335317-2', 'auto');
  ga('send', 'pageview');

</script>


    
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.ihtml");
    });

    </script>


 
		<script type='text/javascript'>

	function loadPlus(plusdocs){
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
	} 

   //function loadInline(json){
   // for (var lookFor in json) {
    //  $(lookFor).after(json[lookFor]);
    // }
  // } // end loadInline


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/2.2.0/plus_Thread.ihtml', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);


//     $.ajax({
//     dataType: "json",
//      url: '/associated/2.2.0/inline_Thread.js',
//      success: function(json) {
// 			setTimeout(function() {
// 				loadInline(json);
// 				}, 2000);
// 			}
//    });

		});
</script>
		
</body>
</html>


